@prefix rutp: <http://rdfunit.aksw.org/data/patterns#> .
@prefix rut: <http://rdfunit.aksw.org/ns/core#> .
@prefix rutg: <http://rdfunit.aksw.org/data/generators#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix dc: <http://purl.org/dc/elements/1.1/> .
@prefix rlog: <http://persistence.uni-leipzig.org/nlp2rdf/ontologies/rlog#> .
@prefix schema: <http://schema.org/> .
@prefix oslc:      <http://open-services.net/ns/core#> .

############################################
### Generates test cases for Types Shapes
### see http://www.w3.org/Submission/2014/SUBM-shapes-20140211/#associating-and-applying-shapes
############################################

# OSLC oslc:range (a single range)
# Class range wrongly defined (single range)
rutg:OSLCRANGEC a rut:TestGenerator ;
    dcterms:description """Generate all oslc:range constrains defined in a schema (when range is wrongly defined)"""@en ;
    rut:sparqlGenerator """ select distinct ?P1  ?T1  ?DESCRIPTION where {
								?s a oslc:ResourceShape .
								?s oslc:describes ?class . # we work only on typed classes
                                ?s oslc:ResourceShape/oslc:property/oslc:propertyDefinition ?P1 .
                                ?s oslc:ResourceShape/oslc:property/oslc:range ?T1 .

                                # don't check for general classes (and oslc:Any)
	                            FILTER (  ?T1 NOT IN ( oslc:Any, owl:Thing, prov:Entity, rdf:Resource, rdf:Class, rdf:Property, schema:Property, schema:Class ))

	                            # Keep unique ranges only
                                FILTER NOT EXISTS {?s dsp:statementTemplate/dsp:nonLiteralConstraint/dsp:valueClass ?T2 .
                                                    FILTER (?T1 != ?T2)
                                }
	                            BIND (concat(str(?P1)," does not have correct range: ", str(?T1)) AS ?DESCRIPTION)} """ ;
    rut:basedOnPattern rutp:RDFSRANGE ;
    rut:resultAnnotation [
        a rut:ResultAnnotation ;
        rut:annotationProperty rlog:level ;
        rut:annotationValue rlog:ERROR] ;
    .

# Class range missing (single range)
rutg:OSLCRANGEC-MISS a rut:TestGenerator ;
    dcterms:description """Generate all oslc:range constrains defined in a schema (when range is missing)"""@en ;
    rut:sparqlGenerator """ select distinct ?P1 ?DESCRIPTION where {
                                ?s a oslc:ResourceShape .
								?s oslc:describes ?class . # we work only on typed classes
                                ?s oslc:ResourceShape/oslc:property/oslc:propertyDefinition ?P1 .
                                ?s oslc:ResourceShape/oslc:property/oslc:range ?T1 .

                                # don't check for general classes
                                FILTER (  ?T1 NOT IN ( oslc:Any, owl:Thing, prov:Entity, rdf:Resource, rdf:Class, rdf:Property, schema:Property, schema:Class ))

                                # Keep unique ranges only
                                FILTER NOT EXISTS {?s oslc:ResourceShape/oslc:property/oslc:range ?T2 .
                                                    FILTER (?T1 != ?T2)
                                }

                                BIND (concat(str(?P1)," does not have correct range: ", str(?T1)) AS ?DESCRIPTION)}  """ ;
    rut:basedOnPattern rutp:RDFSRANGE-MISS ;
    rut:resultAnnotation [
        a rut:ResultAnnotation ;
        rut:annotationProperty rlog:level ;
        rut:annotationValue rlog:WARN] ;
    .

#############
# oslc:occurs (oslc:Exactly-one / oslc:One-or-many / oslc:Zero-or-many / oslc:Zero-or-one)

# oslc:Exactly-one / oslc:One-or-many (must exist at least once)

rutg:PSCARDEX a rut:TestGenerator ;
    dcterms:description """ Generates owl:cardinality constrains. We ensure that the property exists at least once"""@en ;
    rut:sparqlGenerator """ SELECT DISTINCT ?T1 ('NOT' as ?NOT) ?P1 ?DESCRIPTION WHERE {
							 ?s a oslc:ResourceShape .
							 ?s oslc:describes ?class . # we work only on typed classes
                             ?s oslc:ResourceShape/oslc:property/oslc:propertyDefinition ?P1 .
                             ?s oslc:ResourceShape/oslc:property/oslc:occurs ?occurs .
                             FILTER (?occurs IN (oslc:Exactly-one, oslc:One-or-many)) .
							 BIND ( concat("Cardinality of ",  str(?P1)," is 0 for type ", str(?T1)) AS ?DESCRIPTION)} """ ;
    rut:basedOnPattern rutp:TYPRODEP ;
    rut:resultAnnotation [
        a rut:ResultAnnotation ;
        rut:annotationProperty rlog:level ;
        rut:annotationValue rlog:ERROR] ;
    .

#oslc:Exactly-one (ensure only one)
rutg:RSCARD a rut:TestGenerator ;
    dcterms:description """Generates owl:cardinality constrains defined in a schema"""@en ;
    rut:sparqlGenerator """ SELECT DISTINCT ?T1 ?P1 ('!=' as ?OP) ('1'  as ?V1) ?DESCRIPTION WHERE {
							 ?s a oslc:ResourceShape .
							 ?s oslc:describes ?class . # we work only on typed classes
                             ?s oslc:ResourceShape/oslc:property/oslc:propertyDefinition ?P1 .
                             ?s oslc:ResourceShape/oslc:property/oslc:occurs oslc:Exactly-one .
							 BIND ( concat("Cardinality of ",  str(?P1)," different from 1 for type ", str(?T1)) AS ?DESCRIPTION)} """ ;
    rut:basedOnPattern rutp:OWLCARDT ;
    rut:resultAnnotation [
        a rut:ResultAnnotation ;
        rut:annotationProperty rlog:level ;
        rut:annotationValue rlog:ERROR] ;
    .

# oslc:Zero-or-one
rutg:RSGARD-MAX a rut:TestGenerator ;
    dcterms:description """Generates owl:cardinality constrains defined in a schema"""@en ;
    rut:sparqlGenerator """ SELECT DISTINCT ?T1 ?P1 ('>' as ?OP) (str(?v)  as ?V1) ?DESCRIPTION WHERE {
							 ?s a oslc:ResourceShape .
							 ?s oslc:describes ?class . # we work only on typed classes
                             ?s oslc:ResourceShape/oslc:property/oslc:propertyDefinition ?P1 .
                             ?s oslc:ResourceShape/oslc:property/oslc:occurs oslc:Zero-or-one .
							 BIND ( concat("Cardinality of ",  str(?P1)," higher than 1 for type ", str(?T1)) AS ?DESCRIPTION) .} """ ;
    rut:basedOnPattern rutp:OWLCARDT ;
    rut:resultAnnotation [
        a rut:ResultAnnotation ;
        rut:annotationProperty rlog:level ;
        rut:annotationValue rlog:ERROR] ;
    .


############################
# oslc:valueType  (TODO maybe we need to check the property in combination to the domain
############################


# Check for Literal (if not in oslc:AnyResource, oslc:LocalResource, oslc:Resource, then it's a literal)
rutg:RSRANGEL a rut:TestGenerator ;
    dcterms:description """Check all defined Literals if they are indeed literals"""@en ;
    rut:sparqlGenerator """ select distinct ?P1 ('' as ?NEG) ('isIRI' as ?FUNC) ?DESCRIPTION where {
                             ?s a oslc:ResourceShape .
							 ?s oslc:describes ?class . # we work only on typed classes
                             ?s oslc:ResourceShape/oslc:property/oslc:propertyDefinition ?P1 .
                             ?s oslc:ResourceShape/oslc:property/oslc:valueType ?valueType .
                             FILTER (?valueType NOT IN (oslc:AnyResource, oslc:LocalResource, oslc:Resource) )
                             BIND (concat(str(?P1)," does contain a literal value") AS ?DESCRIPTION)} """ ;
    rut:basedOnPattern rutp:OBJFUNC ;
    rut:resultAnnotation [
        a rut:ResultAnnotation ;
        rut:annotationProperty rlog:level ;
        rut:annotationValue rlog:ERROR] ;
	.

# Check for Literal (if not in oslc:AnyResource, oslc:LocalResource, oslc:Resource, then it's a literal)
rutg:RSRANGEC a rut:TestGenerator ;
    dcterms:description """Check all defined Literals if they are indeed literals"""@en ;
    rut:sparqlGenerator """ select distinct ?P1 ('!' as ?NEG) ('isIRI' as ?FUNC) ?DESCRIPTION where {
                             ?s a oslc:ResourceShape .
							 ?s oslc:describes ?class . # we work only on typed classes
                             ?s oslc:ResourceShape/oslc:property/oslc:propertyDefinition ?P1 .
                             ?s oslc:ResourceShape/oslc:property/oslc:valueType ?valueType .
                             FILTER (?valueType IN (oslc:AnyResource, oslc:LocalResource, oslc:Resource) )
                             BIND (concat(str(?P1)," does contain a literal value") AS ?DESCRIPTION)} """ ;
    rut:basedOnPattern rutp:OBJFUNC ;
    rut:resultAnnotation [
        a rut:ResultAnnotation ;
        rut:annotationProperty rlog:level ;
        rut:annotationValue rlog:ERROR] ;
	.

# Datatype range
rutg:RSRANGED a rut:TestGenerator ;
    dcterms:description """Generate all rdfs:range constrains defined in a schema"""@en ;
    rut:sparqlGenerator """ select distinct ?P1 ?D1 ?DESCRIPTION where {
                             ?s a oslc:ResourceShape .
                             ?s oslc:describes ?class . # we work only on typed classes
                             ?s oslc:ResourceShape/oslc:property/oslc:propertyDefinition ?P1 .
                             ?s oslc:ResourceShape/oslc:property/oslc:valueType ?D1 .
                             FILTER (?D1 NOT IN (xsd:string, oslc:AnyResource, oslc:LocalResource, oslc:Resource) )
                             BIND (concat(str(?P1)," does not have datatype: ", str(?D1)) AS ?DESCRIPTION)} """ ;
    rut:basedOnPattern rutp:RDFSRANGED ;
    rut:resultAnnotation [
        a rut:ResultAnnotation ;
        rut:annotationProperty rlog:level ;
        rut:annotationValue rlog:ERROR] ;
    .

# Check for blank nodes (oslc:valueType oslc:LocalResource)
rutg:RSRANGE-BLANK a rut:TestGenerator ;
    dcterms:description """Check all defined Literals if they are indeed literals"""@en ;
    rut:sparqlGenerator """ select distinct ?P1 ('!' as ?NEG) ('isBlank' as ?FUNC) ?DESCRIPTION where {
                             ?s a oslc:ResourceShape .
							 ?s oslc:describes ?class . # we work only on typed classes
                             ?s oslc:ResourceShape/oslc:property/oslc:propertyDefinition ?P1 .
                             ?s oslc:ResourceShape/oslc:property/oslc:valueType oslc:LocalResource .
                             BIND (concat(str(?P1)," does contain a blank node (local resource)") AS ?DESCRIPTION)} """ ;
    rut:basedOnPattern rutp:OBJFUNC ;
    rut:resultAnnotation [
        a rut:ResultAnnotation ;
        rut:annotationProperty rlog:level ;
        rut:annotationValue rlog:ERROR] ;
	.

# Check for non-blank nodes (oslc:valueType oslc:Resource => must not be a blank node)
rutg:RSRANGE-RES a rut:TestGenerator ;
    dcterms:description """Check all defined Literals if they are indeed literals"""@en ;
    rut:sparqlGenerator """ select distinct ?P1 ('' as ?NEG) ('isBlank' as ?FUNC) ?DESCRIPTION where {
                             ?s a oslc:ResourceShape .
							 ?s oslc:describes ?class . # we work only on typed classes
                             ?s oslc:ResourceShape/oslc:property/oslc:propertyDefinition ?P1 .
                             ?s oslc:ResourceShape/oslc:property/oslc:valueType oslc:Resource .
                             BIND (concat(str(?P1)," does contain a blank node (local resource)") AS ?DESCRIPTION)} """ ;
    rut:basedOnPattern rutp:OBJFUNC ;
    rut:resultAnnotation [
        a rut:ResultAnnotation ;
        rut:annotationProperty rlog:level ;
        rut:annotationValue rlog:ERROR] ;
	.
# TODO OSLC allowedValue / allowedValues
# TODO OSLC oslc:maxSize (has to be xsd:string)
# TODO OSLC oslc:valueShape
