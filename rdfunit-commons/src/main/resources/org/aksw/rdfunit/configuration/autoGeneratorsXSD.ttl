@prefix rutp: <http://rdfunit.aksw.org/data/patterns#> .
@prefix rut: <http://rdfunit.aksw.org/ns/core#> .
@prefix rutg: <http://rdfunit.aksw.org/data/generators#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix dc: <http://purl.org/dc/elements/1.1/> .
@prefix rlog: <http://persistence.uni-leipzig.org/nlp2rdf/ontologies/rlog#> .
@prefix schema: <http://schema.org/> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix rdqv: <http://rdfunit.aksw.org/ns/rdqv#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .

#import the xsd rdfs ontology (is defined alongside RDFUnit in the vocabularies folder)
<> owl:imports xsd: .

##########################################
#### NOTE: make sure to load the xsd.ttl into your model (vocabularies folder)
##########################################
#### rdfs:range pattern for XSD datatypes
##########################################

# Datatype range wrongly defined
rutg:XSDRANGEV a rut:TestGenerator ;
    dcterms:description """Check all defined Literals if they are indeed literals""" ;
    rut:sparqlGenerator """ select distinct ?P1 (str(?pattern) as ?REGEX) ?MIN ?MAX ?MINOP ?MAXOP ?XSD ?DESCRIPTION where {

    ?P1 rdfs:range ?D1 .
    FILTER ( STRSTARTS(str(?D1), 'http://www.w3.org/2001/XMLSchema#') ).    # is an XSD type
    FILTER ( ! STRSTARTS(str(?P1), 'http://www.w3.org/2001/XMLSchema#') ).  # is not an XSD property

    # find the datatype regex pattern (not optional, only types which define a pattern)
    ?D1 owl:withRestrictions/rdf:rest*/rdf:first/xsd:pattern ?pattern .

    OPTIONAL{
        ?D1 owl:withRestrictions/rdf:rest*/rdf:first/xsd:minInclusive ?minInc .
    }
    OPTIONAL{
        ?D1 owl:withRestrictions/rdf:rest*/rdf:first/xsd:minExclusive ?minExc .
    }
    OPTIONAL{
        ?D1 owl:withRestrictions/rdf:rest*/rdf:first/xsd:maxInclusive ?maxInc .
    }
    OPTIONAL{
        ?D1 owl:withRestrictions/rdf:rest*/rdf:first/xsd:maxExclusive ?maxExc .
    }

    FILTER (!isBlank(?P1))
    FILTER (!isBlank(?D1))

    BIND (STR(COALESCE(COALESCE(?minInc, ?minExc), '')) AS ?MIN).
    BIND (STR(COALESCE(COALESCE(?maxInc, ?maxExc), '')) AS ?MAX).
    BIND (IF(bound(?minExc), '<', '<=') AS ?MINOP).
    BIND (IF(bound(?maxExc), '>', '>=') AS ?MAXOP).
    BIND (substr(str(?D1), 34) AS ?XSD).
    BIND (concat(str(?P1),' does not match or is out of bounds for type xsd:', ?XSD) AS ?DESCRIPTION)} """ ;

    rut:basedOnPattern rutp:MATCHXSDTYPE ;
    rut:resultAnnotation [
        a rut:ResultAnnotation ;
        rut:annotationProperty rlog:level ;
        rut:annotationValue rlog:ERROR] ;
    rut:resultAnnotation [
        a rut:ResultAnnotation ;
        rut:annotationProperty sh:sourceConstraint ;
        rut:annotationValue rdqv:RangeDatatypeConstraint] ;
    .
