@prefix dc:      <http://purl.org/dc/elements/1.1/> .
@prefix rutg:    <http://rdfunit.aksw.org/data/generators#> .
@prefix rdfs:    <http://www.w3.org/2000/01/rdf-schema#> .
@prefix rlog:    <http://persistence.uni-leipzig.org/nlp2rdf/ontologies/rlog#> .
@prefix owl:     <http://www.w3.org/2002/07/owl#> .
@prefix xsd:     <http://www.w3.org/2001/XMLSchema#> .
@prefix rut:    <http://rdfunit.aksw.org/ns/core#> .
@prefix rdf:     <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rutt:    <http://rdfunit.aksw.org/data/tests#> .
@prefix rutp:    <http://rdfunit.aksw.org/data/patterns#> .
@prefix dcterms:  <http://purl.org/dc/terms/> .


# A lemon:LexicalEntry needs at least one lemon:canonicalForm.
# TODO use TYPRODEP pattern
rutt:lemon-entryWithoutCanonicalForm
      a rut:ManualTestCase ;
      rut:appliesTo rut:Schema ;
      rut:generated rut:ManuallyGenerated ;
      rut:references <http://www.monnet-project.eu/lemon#LexicalEntry>;
      rut:source <http://www.monnet-project.eu/lemon#> ;
      rut:testCaseLogLevel rlog:ERROR ;
      rut:sparqlWhere """ {
                           ?resource rdf:type <http://www.monnet-project.eu/lemon#LexicalEntry> .
                           FILTER (NOT EXISTS {?resource <http://www.monnet-project.eu/lemon#canonicalForm> ?v1 .})
                           # README
                           BIND (concat(str(?resource),": is a lemon:LexicalEntry and needs exactly one lemon:canonicalForm property.") AS ?message)
                            } """ ;
      rut:sparqlPrevalence """ SELECT (count(?resource) AS ?total) WHERE {
                                 ?resource rdf:type <http://www.monnet-project.eu/lemon#LexicalEntry> . } """ .

# A lemon:LexicalEntry should have an rdfs:label
# TODO use TYPRODEP pattern
rutt:lemon-entryWithoutLabel
      a rut:ManualTestCase ;
      rut:appliesTo rut:Schema ;
      rut:generated rut:ManuallyGenerated ;
      rut:references <http://www.monnet-project.eu/lemon#LexicalEntry>;
      rut:source <http://www.monnet-project.eu/lemon#> ;
      rut:testCaseLogLevel rlog:INFO ;
      rut:sparqlWhere """ {
                           ?resource rdf:type <http://www.monnet-project.eu/lemon#LexicalEntry> .
                           FILTER (NOT EXISTS {?resource <http://www.w3.org/2000/01/rdf-schema#label> ?v1 .})
                           # README
                           BIND (concat(str(?resource),": has no rdfs:label.") AS ?message)
                            } """ ;
      rut:sparqlPrevalence """ SELECT (count(?resource) AS ?total) WHERE {
                                 ?resource rdf:type <http://www.monnet-project.eu/lemon#LexicalEntry> . } """ .

# A lemon:LexicalEntry should have exactly one lemon:language.
# TODO use TYPRODEP (exists) & CARDT (exactly once) patterns
rutt:lemon-entryExactlyOneLanguage
      a rut:ManualTestCase ;
      rut:appliesTo rut:Schema ;
      rut:generated rut:ManuallyGenerated ;
      rut:references <http://www.monnet-project.eu/lemon#LexicalEntry>;
      rut:source <http://www.monnet-project.eu/lemon#> ;
      rut:testCaseLogLevel rlog:INFO ;
      rut:sparqlWhere """ {
                           		{?resource rdf:type <http://www.monnet-project.eu/lemon#LexicalEntry> .
                           			FILTER (NOT EXISTS {?resource <http://www.monnet-project.eu/lemon#language> ?lang .})
                           		}UNION{
								 ?resource rdf:type <http://www.monnet-project.eu/lemon#LexicalEntry> .
								 ?resource <http://www.monnet-project.eu/lemon#language> ?lang1 .
								 ?resource <http://www.monnet-project.eu/lemon#language> ?lang2 .
                           			FILTER (?lang1!=?lang2)
								}
                           		# README
	                           BIND (concat(str(?resource),": has no lemon:language property.") AS ?message)
                            } """ ;
      rut:sparqlPrevalence """ SELECT (count(?resource) AS ?total) WHERE {
                                 ?resource rdf:type <http://www.monnet-project.eu/lemon#LexicalEntry> . } """ .

# A lemon:LexicalSense either needs a subsense or exactly one reference
rutt:lemon-lexicalSenseReferenceCount
      a rut:ManualTestCase ;
      rut:appliesTo rut:Schema ;
      rut:generated rut:ManuallyGenerated ;
      rut:references <http://www.monnet-project.eu/lemon#LexicalSense>;
      rut:source <http://www.monnet-project.eu/lemon#> ;
      rut:testCaseLogLevel rlog:ERROR ;
      rut:sparqlWhere """ {
                           		{?resource rdf:type <http://www.monnet-project.eu/lemon#LexicalSense> .
                           			FILTER (NOT EXISTS {?resource <http://www.monnet-project.eu/lemon#subsense> ?sub .})
                                    FILTER (NOT EXISTS {?resource <http://www.monnet-project.eu/lemon#reference> ?ref .})
                           		}UNION{
								 ?resource rdf:type <http://www.monnet-project.eu/lemon#LexicalSense> .
								 ?resource <http://www.monnet-project.eu/lemon#reference> ?ref1 .
								 ?resource <http://www.monnet-project.eu/lemon#reference> ?ref2 .
                           			FILTER (?ref1!=?ref2)
								}
                           		# README
	                           BIND (concat(str(?resource),": is a lemon:LexicalSense and either needs a subsense or exactly one reference.") AS ?message)
                            } """ ;
      rut:sparqlPrevalence """ SELECT (count(?resource) AS ?total) WHERE {
                                 ?resource rdf:type <http://www.monnet-project.eu/lemon#LexicalSense> . } """ .



# Narrower should not be symmetric
# TODO use OWLSYMMETRICPROP pattern
rutt:lemon-narrowerNotSymmetric
      a rut:ManualTestCase ;
      rut:appliesTo rut:Schema ;
      rut:generated rut:ManuallyGenerated ;
      rut:references <http://www.monnet-project.eu/lemon#narrower> ;
      rut:source <http://www.monnet-project.eu/lemon#> ;
      rut:testCaseLogLevel rlog:ERROR ;
      rut:sparqlWhere """ {
                           ?resource <http://www.monnet-project.eu/lemon#narrower> ?narrower .
                           ?narrower <http://www.monnet-project.eu/lemon#narrower> ?resource .
                           # README
                           BIND (concat(str(?resource),": is a broader sense than (",str(?narrower),"), the relation can not be symmetric.") AS ?message)
                          } """ ;
      rut:sparqlPrevalence
              " " .

# Broader should not be symmetric
# TODO use OWLSYMMETRICPROP pattern
rutt:lemon-broaderNotSymmetric
      a rut:ManualTestCase ;
      rut:appliesTo rut:Schema ;
      rut:generated rut:ManuallyGenerated ;
      rut:references <http://www.monnet-project.eu/lemon#broader> ;
      rut:source <http://www.monnet-project.eu/lemon#> ;
      rut:testCaseLogLevel rlog:ERROR ;
      rut:sparqlWhere """ {
                           ?resource <http://www.monnet-project.eu/lemon#broader> ?broader .
                           ?broader <http://www.monnet-project.eu/lemon#broader> ?resource .
                           # README
                           BIND (concat(str(?resource),": is a narrower sense than (",str(?broader),"), the relation can not be symmetric.") AS ?message)
                          } """ ;
      rut:sparqlPrevalence
              " " .

# If a sense is narrower than another, the other should be broader than the first one
rutt:lemon-narrowerNoBroaderInverse
      a rut:ManualTestCase ;
      rut:appliesTo rut:Schema ;
      rut:generated rut:ManuallyGenerated ;
      rut:references <http://www.monnet-project.eu/lemon#broader> ;
      rut:source <http://www.monnet-project.eu/lemon#> ;
      rut:testCaseLogLevel rlog:INFO ;
      rut:sparqlWhere """ {
                           ?resource <http://www.monnet-project.eu/lemon#narrower> ?narrower .
                           FILTER (NOT EXISTS {?narrower <http://www.monnet-project.eu/lemon#broader> ?resource .})
                           # README
                           BIND (concat(str(?resource),": is a broader sense than (",str(?narrower),"), so there should be an inverse lemon:broader property.") AS ?message)
                            } """ ;
      rut:sparqlPrevalence """ SELECT (count(?resource) AS ?total) WHERE {
                                 ?resource <http://www.monnet-project.eu/lemon#narrower> ?narrower . } """ .

# A lemon:component should have at least one lemon:element.
# TODO use TYPRODEP pattern
rutt:lemon-componentNoElement
      a rut:ManualTestCase ;
      rut:appliesTo rut:Schema ;
      rut:generated rut:ManuallyGenerated ;
      rut:references <http://www.monnet-project.eu/lemon#Component> , <http://www.monnet-project.eu/lemon#element> ;
      rut:source <http://www.monnet-project.eu/lemon#> ;
      rut:testCaseLogLevel rlog:WARN ;
      rut:sparqlWhere """ {
                           ?resource rdf:type <http://www.monnet-project.eu/lemon#Component> .
                           FILTER (NOT EXISTS {?resource <http://www.monnet-project.eu/lemon#element> ?v1 .})
                           # README
                           BIND (concat(str(?resource),": is a lemon:Component and needs a lemon:element property.") AS ?message)
                            } """ ;
      rut:sparqlPrevalence """ SELECT (count(?resource) AS ?total) WHERE {
                                 ?resource rdf:type <http://www.monnet-project.eu/lemon#Component> . } """ .

#Language property value should not have a language tag itself
rutt:lemon-languageTagOnLanguageProperty
      a rut:ManualTestCase ;
      rut:appliesTo rut:Schema ;
      rut:generated rut:ManuallyGenerated ;
      rut:references <http://www.lemon-model.net/lemon#language> ;
      rut:source <http://www.monnet-project.eu/lemon#> ;
      rut:testCaseLogLevel rlog:ERROR ;
      rut:sparqlWhere """ {
                           ?resource <http://www.lemon-model.net/lemon#language> ?v1 .
                           FILTER (lang(?v1)!="")
                           # README
                           BIND (concat("Language literals may not have a language tag themselves.") AS ?message)
                            } """ ;
      rut:sparqlPrevalence """ SELECT (count(?resource) AS ?total) WHERE {
                                 ?resource <http://www.lemon-model.net/lemon#language> ?v1 . } """ .

#Rule property value should not have a language tag
rutt:lemon-languageTagOnRuleProperty
      a rut:ManualTestCase ;
      rut:appliesTo rut:Schema ;
      rut:generated rut:ManuallyGenerated ;
      rut:references <http://www.lemon-model.net/lemon#rule> ;
      rut:source <http://www.monnet-project.eu/lemon#> ;
      rut:testCaseLogLevel rlog:ERROR ;
      rut:sparqlWhere """ {
                           ?resource <http://www.lemon-model.net/lemon#rule> ?v1 .
                           FILTER (lang(?v1)!="")
                           # README
                           BIND (concat("Rule literals may not have a language tag.") AS ?message)
                            } """ ;
      rut:sparqlPrevalence """ SELECT (count(?resource) AS ?total) WHERE {
                                 ?resource <http://www.lemon-model.net/lemon#rule> ?v1 . } """ .

#check for multiple lemon types

#Strings should have language tags, language tags should match a regex (may take a long time to query, omitted)