# W3C Shapes Constraint Language (SHACL) Vocabulary
# Draft last edited 2017-04-13

@prefix owl:  <http://www.w3.org/2002/07/owl#> .
@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd:  <http://www.w3.org/2001/XMLSchema#> .

@prefix sh:   <http://www.w3.org/ns/shacl#> .
@prefix shr:  <http://rdfunit.aksw.org/ns/shacl-ext#> .


sh:
	sh:declare [
		sh:prefix "sh" ;
		sh:namespace "http://www.w3.org/ns/shacl#" ;
	] ;
	sh:declare [
		sh:prefix "shr" ;
		sh:namespace "http://rdfunit.aksw.org/ns/shacl-ext#" ;
	] ;
	.

###############################
### Value type CCs ##########
###############################


sh:ClassConstraintComponent
    a sh:ConstraintComponent ;
	sh:parameter [
        sh:path sh:class ;
    ] ;
    sh:validator [
    	a sh:SPARQLAskValidator ;
    	sh:message "value not of type $class";
    	sh:ask """
    		ASK {
            	$value rdf:type/rdfs:subClassOf* $class .
            }""" ;
    ] ;
    .


sh:DatatypeConstraintComponent
    a sh:ConstraintComponent ;
	sh:parameter [
        sh:path sh:datatype ;
    ] ;
    sh:validator [
    	a sh:SPARQLAskValidator ;
    	sh:message "value not of type $datatype";
    	sh:ask """
    		ASK {
            	FILTER ( isLiteral($value) && datatype($value) = $datatype)
            }""" ;
    ] ;
    .

sh:NodeKindConstraintComponent
	a sh:ConstraintComponent ;
	sh:parameter [
		sh:path sh:nodeKind ;
	] ;
    sh:validator [
        # when flags are present
        a sh:SPARQLAskValidator ;
        sh:message "sh:nodeKind of $path should be '$nodeKind'" ;
        shr:filter """ ASK { FILTER ($nodeKind = <http://www.w3.org/ns/shacl#IRI>)} """ ;
        sh:ask """
            ASK {
                FILTER (isIRI(?value) ) .
            }""" ;
    ] ;
    sh:validator [
        # when flags are present
        a sh:SPARQLAskValidator ;
        sh:message "sh:nodeKind of $path should be '$nodeKind'" ;
        shr:filter """ ASK { FILTER ($nodeKind = <http://www.w3.org/ns/shacl#Literal>)} """ ;
        sh:ask """
            ASK {
                FILTER (isLiteral(?value)) .
            }""" ;
    ] ;
    sh:validator [
        # when flags are present
        a sh:SPARQLAskValidator ;
        sh:message "sh:nodeKind of $path should be '$nodeKind'" ;
        shr:filter """ ASK { FILTER ($nodeKind = <http://www.w3.org/ns/shacl#BlankNode>)} """ ;
        sh:ask """
            ASK {
                FILTER (isBlank(?value)) .
            }""" ;
    ]
    .


###############################
### Value range CCs ##########
###############################


sh:MinExclusiveConstraintComponent
    a sh:ConstraintComponent ;
	sh:parameter [
        sh:path sh:minExclusive ;
        sh:datatype xsd:integer ;
    ] ;
    sh:validator [
    	a sh:SPARQLAskValidator ;
    	sh:message "sh:minExclusive of $path should be '$minExclusive'";
    	sh:ask """
    		ASK {
            	FILTER (?value > $minExclusive) .
            }""" ;
    ] ;
    .


sh:MaxExclusiveConstraintComponent
    a sh:ConstraintComponent ;
	sh:parameter [
        sh:path sh:maxExclusive ;
        sh:datatype xsd:integer ;
    ] ;
    sh:validator [
    	a sh:SPARQLAskValidator ;
    	sh:message "sh:maxExclusive of $path should be '$maxExclusive'";
    	sh:ask """
    		ASK {
            	FILTER (?value < $maxExclusive) .
            }""" ;
    ] ;
    .

sh:MinInclusiveConstraintComponent
    a sh:ConstraintComponent ;
	sh:parameter [
        sh:path sh:minInclusive ;
        sh:datatype xsd:integer ;
    ] ;
    sh:validator [
    	a sh:SPARQLAskValidator ;
    	sh:message "sh:minInclusive of $path should be '$minInclusive'";
    	sh:ask """
    		ASK {
            	FILTER (?value >= $minInclusive) .
            }""" ;
    ] ;
    .


sh:MaxInclusiveConstraintComponent
    a sh:ConstraintComponent ;
	sh:parameter [
        sh:path sh:maxInclusive ;
        sh:datatype xsd:integer ;
    ] ;
    sh:validator [
    	a sh:SPARQLAskValidator ;
    	sh:message "sh:maxExclusive of $path should be '$maxInclusive'";
    	sh:ask """
    		ASK {
            	FILTER (?value <= $maxInclusive) .
            }""" ;
    ] ;
    .

###############################
### String-based CCs ##########
###############################

sh:MinLengthConstraintComponent
    a sh:ConstraintComponent ;
	sh:parameter [
        sh:path sh:minLength ;
        sh:datatype xsd:integer ;
    ] ;
    sh:validator [
    	a sh:SPARQLAskValidator ;
    	shr:filter "ASK { FILTER ($minLength > 0)}" ;
    	sh:message "The minimum length of '$path' is '$minLength'";
    	sh:ask """
    		ASK {
            	FILTER (
            	    STRLEN(str($value)) >= $minLength) .
            }""" ;
    ] ;
    .

sh:MaxLengthConstraintComponent
    a sh:ConstraintComponent ;
	sh:parameter [
        sh:path sh:maxLength ;
        sh:datatype xsd:integer ;
    ] ;
    sh:validator [
    	a sh:SPARQLAskValidator ;
    	#shr:filter "ASK { FILTER ($maxLength >= 0)}" ;
    	sh:message "The maximum length of '$path' is '$maxLength'";
    	sh:ask """
    		ASK {
            	FILTER (
            	    STRLEN(str($value)) <= $maxLength) .
            }""" ;
    ] ;
    .


sh:PatternConstraintComponent
	a sh:ConstraintComponent ;
	sh:parameter [
		sh:path sh:pattern ;
	] ;
	sh:parameter [
		sh:path sh:flags ;
		sh:optional true ;
	] ;
    sh:validator [
        # when flags are present
        a sh:SPARQLAskValidator ;
        sh:message "Value does not match pattern {$pattern} and flags {$flags}" ;
        shr:filter "ASK { BIND ('$flags' AS ?myFlags) .FILTER (str(?myFlags) != '')}" ;
        sh:ask """
            ASK {
                FILTER (!isBlank($value) &&  regex(str($value), "$pattern", "$flags"))
            }""" ;
    ] ,
    [
        # when flags are not present
        a sh:SPARQLAskValidator ;
        sh:message "Value does not match pattern {$pattern}" ;
        shr:filter "ASK { BIND ('$flags' AS ?myFlags) .FILTER (str(?myFlags) = '')}" ;
        sh:ask """
            ASK {
                FILTER (!isBlank($value) && regex(str($value), "$pattern"))
            }""" ;

    ]
    .


sh:UniqueLangConstraintComponent
    a sh:ConstraintComponent ;
	sh:parameter [
        sh:path sh:uniqueLang ;
        sh:datatype xsd:boolean ;
    ] ;
    sh:validator [
    	a sh:SPARQLAskValidator ;
    	shr:filter "ASK { FILTER ($uniqueLang) . }" ;
    	sh:message "$path should have one value per language";
    	sh:ask """
    		ASK {
            	BIND (lang(?value) AS ?lang) .
                FILTER (?lang != "") .
                FILTER NOT EXISTS {
                    ?this $path ?otherValue .
                    FILTER (?otherValue != ?value && ?lang = lang(?otherValue)) .
            }}""" ;
    ] ;
    .


################################
### Property Pair CCs ##########
################################

sh:EqualsConstraintComponent
    a sh:ConstraintComponent ;
	sh:parameter [
        sh:path sh:equals ;
    ] ;
    sh:validator [
    	a sh:SPARQLAskValidator ;
    	sh:message "$path should be equal to '$equals'";
    	sh:ask """
    		ASK {
            	?this $equals ?value .
            }""" ;
    ] ;
    .

sh:DisjointConstraintComponent
    a sh:ConstraintComponent ;
	sh:parameter [
        sh:path sh:disjoint ;
    ] ;
    sh:validator [
    	a sh:SPARQLAskValidator ;
    	sh:message "$path should no be equal to '$disjoint'";
    	sh:ask """
    		ASK {
            	?this $equals ?value2 .
            	FILTER (?value != ?value2) .
            }""" ;
    ] ;
    .



sh:LessThanConstraintComponent
    a sh:ConstraintComponent ;
	sh:parameter [
        sh:path sh:lessThan ;
    ] ;
    sh:validator [
    	a sh:SPARQLAskValidator ;
    	sh:message "$path should be less than '$lessThan'";
    	sh:ask """
    		ASK {
            	?this $lessThan ?value2 .
                FILTER (?value < ?value2) .
            }""" ;
    ] ;
    .


sh:LessThanOrEqualsConstraintComponent
    a sh:ConstraintComponent ;
	sh:parameter [
        sh:path sh:lessThanOrEquals ;
    ] ;
    sh:validator [
    	a sh:SPARQLAskValidator ;
    	sh:message "$path should be less than '$lessThanOrEquals'";
    	sh:ask """
    		ASK {
            	?this $lessThanOrEquals ?value2 .
                FILTER (?value < ?value2) .
            }""" ;
    ] ;
    .

