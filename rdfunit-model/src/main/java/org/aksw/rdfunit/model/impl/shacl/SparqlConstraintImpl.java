package org.aksw.rdfunit.model.impl.shacl;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import lombok.*;
import org.aksw.rdfunit.enums.RLOGLevel;
import org.aksw.rdfunit.enums.TestAppliesTo;
import org.aksw.rdfunit.enums.TestGenerationType;
import org.aksw.rdfunit.model.helper.MessagePrebinding;
import org.aksw.rdfunit.model.helper.QueryPrebinding;
import org.aksw.rdfunit.model.impl.ManualTestCaseImpl;
import org.aksw.rdfunit.model.interfaces.ResultAnnotation;
import org.aksw.rdfunit.model.interfaces.TestCase;
import org.aksw.rdfunit.model.interfaces.TestCaseAnnotation;
import org.aksw.rdfunit.model.interfaces.shacl.Shape;
import org.aksw.rdfunit.model.interfaces.shacl.ShapePath;
import org.aksw.rdfunit.model.interfaces.shacl.SparqlConstraint;
import org.aksw.rdfunit.model.interfaces.shacl.Validator;
import org.aksw.rdfunit.utils.JenaUtils;
import org.aksw.rdfunit.vocabulary.SHACL;
import org.apache.jena.query.Query;
import org.apache.jena.query.QueryFactory;
import org.apache.jena.rdf.model.Literal;
import org.apache.jena.rdf.model.Resource;
import org.apache.jena.rdf.model.ResourceFactory;

import java.util.Set;
import java.util.stream.Collectors;

@Builder
@Value
@EqualsAndHashCode(exclude = "sparqlWhere")
public class SparqlConstraintImpl implements SparqlConstraint {
    @Getter @NonNull private final Shape shape;
    @Getter @NonNull private final Literal message;
    @Getter @NonNull private final Resource severity;
    @NonNull private final Validator validator;
    @Getter(lazy = true) @NonNull private final String sparqlWhere = generateSparqlWhere(validator.getSparqlQuery());


    @Override
    public TestCase getTestCase() {

        ManualTestCaseImpl.ManualTestCaseImplBuilder testBuilder = ManualTestCaseImpl.builder();
        String sparql;
        sparql = getSparqlWhere();


        return testBuilder
                .element(createTestCaseResource())
                .sparqlPrevalence("")
                .sparqlWhere(sparql)
                .prefixDeclarations(validator.getPrefixDeclarations())
                .testCaseAnnotation(generateTestAnnotations(validator.getSparqlQuery()))
                .build();
    }

    private String generateSparqlWhere(String sparqlString) {

        final String valuePath = shape.getPath()
                .map(ShapePath::asSparqlPropertyPath)
                .map(propertyPath -> " $this " + propertyPath + " $value . ")
                //.orElse(" BIND ($this AS $value) . ");
                .orElse("");


        String  sparqlWhere = sparqlString
                .substring(sparqlString.indexOf('{') + 1);
        return replaceBindings("{" + valuePath + sparqlWhere);
    }

    private String replaceBindings(String sparqlSnippet) {
        QueryPrebinding queryPrebinding = new QueryPrebinding(sparqlSnippet, shape);
        queryPrebinding.validateSparqlQuery();
        return queryPrebinding.applyBindings(ImmutableMap.of());
    }


    private Literal generateMessage() {

        if (shape.getMessage().isPresent()) {
            return shape.getMessage().get();
        } else {
            String messageLanguage = message.getLanguage();
            String message = new MessagePrebinding(this.message.getLexicalForm(), shape).applyBindings();
            if (messageLanguage == null || messageLanguage.isEmpty()) {
                return ResourceFactory.createStringLiteral(message);
            } else {
                return ResourceFactory.createLangLiteral(message, messageLanguage);
            }
        }
    }

    // hack for now
    private TestCaseAnnotation generateTestAnnotations(String originalSelectQuery) {
        return new TestCaseAnnotation(
                createTestCaseResource(),
                TestGenerationType.AutoGenerated,
                null,
                TestAppliesTo.Schema, // TODO check
                SHACL.namespace,      // TODO check
                ImmutableSet.of(),
                generateMessage().getLexicalForm(),
                RLOGLevel.ERROR, //FIXME
                createResultAnnotations(originalSelectQuery)
        );
    }

    private Set<ResultAnnotation> createResultAnnotations(String originalSelectQuery) {
        String prefixes = validator.getPrefixDeclarations().stream()
                .map(p -> "PREFIX " + p.getPrefix() + ": <" + p.getNamespace() + ">")
                .collect(Collectors.joining("\n"));

        String originalSelectClause = validator.getSparqlQuery().substring(0,validator.getSparqlQuery().indexOf('{'));
        String constructedQuery = prefixes + "\n" + originalSelectClause + getSparqlWhere()

                .replaceFirst("(?i)\\s*ASK\\s*\\{", "SELECT \\?this WHERE \\{");

        try {
            Query query = QueryFactory.create(constructedQuery);

            return ResultAnnotationParser.builder()
                    .query(query)
                    .shape(shape)
                    .validator(validator)
                    .canBindValueVariable(true)
                    .build()
                    .getResultAnnotations();
        } catch (Exception e) {

            throw new IllegalArgumentException(constructedQuery, e);
        }



    }

    private Resource createTestCaseResource() {
        // FIXME temporary solution until we decide how to build stable unique test uris
        return ResourceFactory.createProperty(JenaUtils.getUniqueIri());
    }
}
